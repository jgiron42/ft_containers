//
// Created by jgiron on 11/19/21.
//

#ifndef FT_CONTAINERS_SHITTY_ALLOCATOR_HPP
#define FT_CONTAINERS_SHITTY_ALLOCATOR_HPP
#include <sys/mman.h>
#include <unistd.h>
#include <vector>

typedef struct shitty_allocator_s_node {
	struct shitty_allocator_s_node				*next;
	struct shitty_allocator_s_node				*prev;
	size_t			n;
}				shitty_allocator_node;
typedef struct shitty_allocator_s_data {
	shitty_allocator_node				*begin;
	shitty_allocator_node				*end;
}				shitty_allocator_data;

std::vector<shitty_allocator_data> shitty_allocator_all_data;

template< class T >
class shitty_allocator {
public:
	typedef T *				pointer;
	typedef const T *		const_pointer;
	typedef void *			void_pointer;
	typedef const void *	const_void_pointer;
	typedef T				value_type;
	typedef size_t			size_type;
	typedef size_t			difference_type;
	struct propagate_on_container_copy_assignment : public std::true_type  {};

	template<typename U>
	struct rebind {
		typedef shitty_allocator<U> other;
	};

private:
	shitty_allocator_data *_data;
public:
	shitty_allocator() :_data(&*shitty_allocator_all_data.insert(shitty_allocator_all_data.end(), (shitty_allocator_data){NULL, NULL})) {
	};
	shitty_allocator(shitty_allocator &src) : _data(src._data) {}
	template <typename U>
	shitty_allocator(const shitty_allocator<U> &src) : _data(src._data) {}
	pointer allocate(size_type n)
	{
		return (allocate(n, NULL));
	}
	pointer allocate(size_type n, void *cvp)
	{
		shitty_allocator_node	*tmp = (shitty_allocator_node *)mmap(cvp, sizeof(shitty_allocator_node) + n * sizeof(value_type), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
		if (tmp == (void *)-1)
			throw std::bad_alloc();
		tmp->next = NULL;
		tmp->n = n;
		if (!_data->begin) {
			_data->begin = tmp;
			_data->end = _data->begin;
			tmp->prev = NULL;
		}
		else {
			_data->end->next = tmp;
			tmp->prev = _data->end;
			_data->end = tmp;
		}
		return ((pointer)((char*)tmp + sizeof(shitty_allocator_node)));
	}
	void	deallocate(pointer p, size_type n)
	{
		shitty_allocator_node *current = ((shitty_allocator_node *)((char*)p - sizeof (shitty_allocator_node)));
		shitty_allocator_node *tmp = _data->begin;
		while (tmp)
		{
			if (tmp == current)
				break;
			tmp = tmp->next;
		}
		if (!tmp)
		{
			write(2, "shitty_allocator: pointer being freed was not allocated by this allocator\n", 74);
			abort();
		}
		shitty_allocator_node *before = current->prev;
		shitty_allocator_node *after = current->next;
		if (before)
			before->next = after;
		else
			_data->begin = after;
		if (after)
			after->prev = before;
		else
			_data->end = before;
		munmap(current, sizeof(shitty_allocator_node) + n * sizeof(value_type));
	}
	void	construct(pointer p, const value_type &src)
	{
		new (p) value_type(src);
	}
	void	destroy(pointer p)
	{
		p->~value_type();
	}
	size_type max_size() const
	{
		return (std::numeric_limits<size_type>::max() / sizeof(value_type));
	}
	bool operator==(const shitty_allocator &other) const {return (false);}
	bool operator!=(const shitty_allocator &other) const {return (true);}
};

#endif //FT_CONTAINERS_SHITTY_ALLOCATOR_HPP
